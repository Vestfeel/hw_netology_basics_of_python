# -*- coding: utf-8 -*-
"""pyda_datatypes_cycles_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CHGq2Cy7hhXuWjrBuXNgjXDAQhyc6iRK

# Типы данных и циклы. Часть 1

**Булыгин Олег**
* [Я в LinkedIn](https://www.linkedin.com/in/obulygin/)  
* [Мой канал в ТГ по Python](https://t.me/pythontalk_ru)
* [Чат канала](https://t.me/pythontalk_chat)
* [Блог в Телетайпе](https://teletype.in/@pythontalk)

Ссылочки в ноутбуке ведут на полезные доп. материалы, обязательно всё изучайте :)

## [f-строки](https://teletype.in/@pythontalk/f_strings)
Добавляя префикс `f` к строке можно встраивать в нее произвольные выражения при помощи фигурных скобок – `{ }`.

Можно разделять периоды чисел любым разделителем
"""

year_salary = 10000000

res_string = f'Годовая зарплата: ${year_salary :,}'
print(res_string)

"""Можно представлять числа с округлением до нужного количества знаков"""

pi_value = 3.141592653589793

print(f'Число Пи: {pi_value :.2f}')

"""Выведем результат в виде:
```
Масса Плутона составляет около 1.3e+22 кг (это 0.218% массы Земли). Это дом для 52,910,390 плутонианцев.
```
"""

planet = 'плутон'
pluto_mass = 1.303 * 10**22
earth_mass = 5.9722 * 10**24
population = 52910390

res = f'Масса {planet.capitalize()}а составляет около {pluto_mass :.1e} кг (это {pluto_mass / earth_mass :.3%} от массы Земли). Это дом для {population :,} плутонианцев.'
res

"""## Небольшое повторение списков

Прежде чем будем работать с циклами :)

Определите длину каждого из этих списков
"""

a = [1, 2, 3]
b = [1, [2, 3]]
c = []
d = [1, 2, 3][1:]

"""Полезные карточки по спискам:
- как [удалять дубли в списках](https://teletype.in/@pythontalk/remove_duplicates)
- как [добавлять элементы в списки](https://teletype.in/@pythontalk/append_lists)
- как [удалять элементы из списков](https://teletype.in/@pythontalk/list_remove)

## Повторим циклы

### Цикл while

[Гипотеза Коллатца](https://ru.wikipedia.org/wiki/Гипотеза_Коллатца) гласит, что любое натуральное число сводится к единице при следующих действиях над ним:

а) если число чётное, то разделить его пополам;

б) если число нечётное, то умножить его на 3, прибавить 1 и результат разделить на 2.

Над вновь полученным числом вновь повторить действия `a` или `б` в зависимости от чётности числа. Рано или поздно число станет равным 1.

Кому интересно, можно ещё посмотреть ролик на [YouTube](
https://www.youtube.com/watch?v=QgzBDZwanWA).

Напишем программу, проверяющую гипотезу Коллатца. Пусть пользователь вводит любое натуральное число. Будем выполнять в цикле над ним вышеуказанные действия, пока оно не станет равным 1. Если гипотеза верна, то рано или поздно цикл закончится, а если нет - то произойдет зацикливание программы.
"""

n = int(input('Введите число: '))

counter = 0

while n != 1:
    if n % 2 == 0:
        n //= 2
    else:
        n = (3 * n + 1) // 2
    counter += 1


print(n)
print(counter)

"""### Циклы по структуре без вложений

Выведем на экран список всех слов длиннее `n` букв из текста
"""

text = 'Python — высокоуровневый язык программирования, ориентированный на повышение производительности разработчика и читаемости кода.'
n = 15

text.split()

import re

res = []


for word in re.sub('[^\w\s]', '', text).split():
    # print(word)
    if len(word) > n:
        res.append(word)

res

"""Необходимо у пользователя запрашивать набор чисел разделенных пробелом. В результате в отсортированном порядке должны выводиться числа, которые повторяются в вводе более одного раза."""

numbers = input('Введите числа через пробел: ').split()

res = []

for number in numbers:
    if numbers.count(number) > 1 and int(number) not in res:
        res.append(int(number))

print(sorted(res))

'11' > '2'

sum_ = 0
number = 1
while number != 0:
    number = int(input('Введите число: '))
    sum_ += number

print(sum_)

while True:
    number = int(input('Введите число: '))

    if number == 0:
        break

    sum_ += number

print(sum_)

"""### Цикл for по структуре с вложениями

Найдём сумму элементов по главной диагонали квадратной "матрицы".
"""

data = [
    [13, 25, 23, 34],
    [45, 32, 44, 47],
    [12, 33, 23, 95],
    [13, 53, 34, 35]
]

sum_ = 0
index = 0
for row in data:
    # print(row)
    # print(index)
    sum_ += row[index]
    index += 1

print(sum_)

sum_ = 0
index = -1
for row in data:
    sum_ += row[index]
    index -= 1

print(sum_)

"""### Всегда ли нужны вложенные циклы?

Выведем фамилии построчно с указанием профессии в формате:

```
IT:
Гейтс
Джобс
Возняк

Искусство:
Пикассо
Моне
Ван Гог

...
```


"""

professions = ['IT', 'Искусство', 'Спорт', 'Музыка']
persons = [['Гейтс', 'Джобс', 'Возняк'], ['Пикассо', 'Моне', 'Ван Гог'], ['Федерер', 'Надаль'], ['Моцарт', 'Бах']]

for pro, names in zip(professions, persons):
    print(f'{pro}:')
    # print(pro + ':')
    for name in names:
        print(name)
    print()

for pro, names in zip(professions, persons):
    for name in names:
        print(f'{pro}: {name}')
    print()

"""Вспоминаем один из принципов PEP20: Flat is better than nested

Если ваша задача решается без использования вложенных списков, то лучше обойтись без них.
"""

for pro, names in zip(professions, persons):
    print(f'{pro}:')
    print(names)
    print()

for pro, names in zip(professions, persons):
    print(f'{pro}:')
    print('\n'.join(names))
    print()

"""Напишем программу, которая выведет на экран таблицу умножения (Таблица Пифагора)"""

for i in range(1, 10):
    for j in range(1, 10):
        print(i * j, end='\t')
    print()

"""### Какие бывают неочевидные решения простых задач?

Как можно "разгладить" список. Задачка на мышление  
Должен получится результат:

`['Екатеринбург', 'Москва', 'Санкт-Петербург', 'Норильск', 'Пермь', 'Астрахань']`
"""

my_list = [['Екатеринбург', 'Москва'], ['Санкт-Петербург', 'Норильск'], ['Пермь', 'Астрахань']]
my_list

res = []

for row in my_list:
    res += row

print(res)

sum(my_list[1:], [])

sum([5, 67, 7, 345, 436][1:])

help(sum)



"""Данный код вызывает функцию `sum()` с двумя аргументами: `my_list` и пустым списком `[]`.

Функция `sum()` используется для вычисления суммы элементов. В данном случае, она будет применяться к `my_list`.

Второй аргумент `[]` задает начальное значение для суммирования. В данном случае, это пустой список, что означает, что сумма начинается с него.

Таким образом, данный код вычислит сумму всех элементов в `my_list`.
"""

sum(my_list, [])

"""### else и циклы
В Python, `else` может использоваться с циклами `for` и `while`. `else` выполнится после завершения цикла, если он не был прерван оператором `break`.

Напишем игру "Угадай число"
"""

import random

number = random.randint(1, 100)
print(number)
max_tries = 3

while max_tries != 0:
    guess = int(input('Назови свой вариант'))
    if guess < number:
        print('Загаданное число больше')
    elif guess > number:
        print('Загаданное число меньше')
    else:
        print('Ты победил!')
        break
    max_tries -= 1
else:
    print('Ты проиграл')
    print(f'Было загадано число: {number}')

"""## Продолжаем с регулярками

"""

import re

"""### Функция split

`split(pattern, string)` (англ. «расщеплять, разбивать») разделяет строку `string` по границе шаблона `pattern`.
"""

columns = 'Столбец1,Столбец2;Столбец3, Столбец4; Столбец5'
res = re.split('[,;]\s?', columns)

print(res)

"""Границы деления строки проходят там, где метод встретил указанный в аргументе шаблон.

Количеством делений строки можно управлять. За это отвечает параметр `maxsplit` метода `split()` (по умолчанию равен 0).
"""

columns = 'Столбец1,Столбец2;Столбец3, Столбец4; Столбец5'
res = re.split('[,;]\s?', columns, maxsplit=1)

print(res)

"""### Функция `findall`

`findall(pattern, string)` возвращает список всех подстрок в `string`, удовлетворяющих шаблону `pattern`. А не только первую подходящую подстроку, как `search()`.

Найдем хэштеги в сообщении
"""

x = 'когда #эпидемия, то обязательно #оставайсядома'

print(re.findall('#\w+', x))

"""Вытащим номера телефонов и текста"""

phone_numbers = 'Мария: 8-943-342-23-32 Александр: 8-323-432-23-67'

phone_pattern = '\d-\d{3}-\d{3}-\d{2}-\d{2}'
print(re.findall(phone_pattern, phone_numbers))

"""Наёдем словосочетание "регулярные выражениия" во всех словоформах

"""

text = """Что такое регулярные выражения и как их использовать?
Говоря простым языком, регулярное выражение — это последовательность символов, используемая для поиска и замены текста в строке или файле. Как уже было упомянуто,
их поддерживает множество языков общего назначения: Python, Perl, R.
Так что изучение регулярных выражений рано или поздно пригодится."""

pattern = '[Рр]егулярн[а-я]{2,3} выражен[а-я]{2,4}'

print(re.findall(pattern, text))

"""### Скобочные группы

Часть шаблона можно заключить в скобки (...). Это называется «скобочная группа».
Это позволяет:  
- поместить часть шаблона в отдельную структуру (группу);
- если установить квантификатор после скобок, то он будет применяться ко всему содержимому скобки, а не к одному символу.

При наличии подгрупп в шаблоне можно ссылаться на них через их порядковый номер при помощи \1, \2, \3, …  

Группам можно давать собственные имена при помощи (?P<имя>...)

Выделим группы символов из посадочного талона, где:
- первые 2 символа - это авиакомпания;
- 4 следующие символа - номер рейса;
- 3 следующих символа - аэропорт отправления;
- 3 следюущих - аэропорт прибытия;
- оставшиеся - дата рейса.

Предполагаем, что все буквы всегда в верхнем регистре
"""

flight = """
Boarding pass: LA4214 AER-CDB 06NOV
Boarding pass: LA4215 AER-CDB 07NOV
"""

regex_flight = '([A-Z]{2})(\d{4})\s([A-Z]{3})-([A-Z]{3})\s(\d{2}[A-Z]{3})'

flight_match_result = re.search(regex_flight, flight)

print(flight_match_result)

print(flight_match_result.group()) # мы можем получать отдельные скобочные группы по их номерам

"""`findall` же вернёт список кортежей с совпадениям по скобочным группам при соответсвии с шаблоном


"""

regex_flight = '([A-Z]{2})(\d{4})\s([A-Z]{3})-([A-Z]{3})\s(\d{2}[A-Z]{3})'

flight_match_result = re.findall(regex_flight, flight)
print(flight_match_result)

"""Посчитаем количество лайков и репостов"""

messages = ['Опять дождь! Лайков: 2', 'Крутой был концерт 21 августа! Лайков: 28, Ответов: 22']

likes = 0
replies = 0
for msg in messages:
    likes_pattern = re.search('Лайков:\s(\d+)', msg)
    replies_pattern = re.search('Ответов:\s(\d+)', msg)
    if likes_pattern:
        likes += int(likes_pattern.group(1))
    if replies_pattern:
        replies += int(replies_pattern.group(1))

print(likes)
print(replies)

"""Как нам найти все изображения в потенциально огромном списке файлов буквально в пару строк кода? За изображения будем считать файлы с расширениями jpg, png и gif.

Для каждого подходящего файла будем выводить фразу
`Изображение найдено: название файла`,
а если файл не подходит, то `"Название файла" не является изображением`.
"""

file_name_list = ['my.profile', 'conspect.doc', 'my_photo.jpg', 'error-jpg', 'img0912.png', 'index.html', 'favicon.gif', 'img_copy.jpg.tmp', 'some_img.jpg.jpg']

pattern = '.+(\.(jpg|png|gif))+$'

for file_ in file_name_list:
    if re.search(pattern, file_):
        print(f'Изображение найдено: {file_}')
    else:
        print(f'{file_} не является изображением')

"""Переведем даты к другому формату при помощи групп"""

date = 'some text 08/30/1991 some text 10/29/1992'
print(re.sub('(\d\d)/(\d\d)/(\d{4})', r'\2.\1.\3', date))

"""В Python символ `r` перед строкой означает "сырую" строку (raw string). Это означает, что все символы в этой строке будут интерпретироваться буквально и не будут обрабатываться как специальные символы.

Удалим все последовательные повторы слов из текста
"""

some_string = 'Напишите код, который будет будет будет будет удалять все все все все последовательные повторы слов из из из из заданной строки строки при помощи регулярных выражений.'

print(re.sub(r'(\w+)(\s+\1)+', r'\1', some_string))

"""## Что ещё почитать?

- [Шпаргалка по типам данных](https://teletype.in/@pythontalk/datatypes_python
) в Python
- Подробный материал про [структуры данных и алгоритмы в Python](https://teletype.in/@pythontalk/data_structures_algorithms), для продвинутых.
"""

