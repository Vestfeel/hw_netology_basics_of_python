# -*- coding: utf-8 -*-
"""pyda_basics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/163RelykXqDIhXx0_xS5Wnw4Iv9APZ-j1

# Основы Python

**Булыгин Олег**
* [Я в LinkedIn](https://www.linkedin.com/in/obulygin/)  
* [Мой канал в ТГ по Python](https://t.me/pythontalk_ru)
* [Чат канала](https://t.me/pythontalk_chat)
* [Блог в Телетайпе](https://teletype.in/@pythontalk)

Ссылочки в ноутбуке ведут на полезные доп. материалы, обязательно всё изучайте :)

## PEP

PEP (python enhanced proposal — заявки на улучшение языка python). Это технические документы, в которых предлагаются новые возможности, улучшения или изменения в языке Python. PEP являются основным механизмом для предложения новых функций, сбора обратной связи от сообщества на предложения и документирования дизайна, который был принят в Python.

### PEP20 – Zen of Python

Python придерживается философии, которую сформулировал Тим Петерс в 19 принципах. Её текст выдаётся интерпретатором Python по команде `import this`.
"""

import this

"""### PEP8

PEP8 – соглашение о том, как писать код для языка python.
Ключевая идея такова: код читается намного больше раз, чем пишется. Собственно, рекомендации о стиле написания кода направлены на то, чтобы улучшить читаемость кода и сделать его согласованным между большим числом проектов. В идеале, весь код будет написан в едином стиле, и любой сможет легко его прочесть.

[Тут](https://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html) есть перевод на русский, а [тут](https://teletype.in/@pythontalk/var_names_checklist) можете ознакомиться с рекомендациями по именованию [переменных](https://teletype.in/@pythontalk/variables).

## Дополнительная информация об [операторах присваивания](https://t.me/pythontalk_ru/1213)

### Сокращённая запись операторов присваивания
"""

x = 2

# x = x + 1
x += 1
print(x)

# x = x - 1
x -= 1
print(x)

# x = x * 2
x *= 2
print(x)

# x = x / 2
x /= 2
print(x)

"""### Множественное присваивание

В Python существует множественное присваивание, которое позволяет присваивать значения нескольким переменным одновременно. 
При множественном присваивании порядок присваивания формируется слева направо. Количество значений и количество переменных справа и слева от оператора присваивания должно совпадать.
"""

name = 'John'
pro = 'Data Scientist'
salary = 100000

name, pro, salary = 'John', 'Data Scientist', 100000
print(name)
print(pro)
print(salary)

"""Благодаря множественному присваиванию в Python легко решается задача замены переменных местами.

В других языках эта задача решается через третью переменную.
"""

answer = 42
code = 4815162342

c = answer

answer = code
code = c

print(answer, code)

"""А в Python можно так:"""

answer, code = code, answer
print(answer, code)

"""### Моржовый оператор

Этот оператор, который обозначается как `:=` был введен не так давно в Python 3.8. Он позволяет присваивать и возвращать значение в одном выражении. Это может быть полезно, 
когда вам использовать значение в условии или цикле, а также одновременно присвоить это значение переменной для дальнейшего использования.


"""

s = "Hello, World!"
if (n := len(s)) > 10:
    print("Строка содержит больше 10 символов.")

print(n)

"""В этом примере мы используем моржовый оператор для присваивания длины строки переменной "n" и проверки, больше ли эта длина 10. 
Если условие выполняется, мы выводим сообщение, используя значение "n".

Без моржового оператора это выглядело бы так:
"""

s = "Hello, World!"
n = len(s)
if n > 10:
    print("Строка содержит больше 10 символов.")

print(n)

"""Здесь мы используем моржовый оператор для присваивания результата умножения числа "x" на само себя переменной "y" и проверки, больше ли этот результат 20. Если условие выполняется, мы выводим сообщение, используя значения "x" и "y".


"""

x = 5
if (y := x ** 2) > 20:
    print("Квадрат числа", x, "равен", y, "и больше 20.")

print(y)

"""Без моржового оператора это выглядело бы так:"""

x = 5
y = x ** 2
if y > 20:
    print("Квадрат числа", x, "равен", y, "и больше 20.")

print(y)

"""Более продвинутую информацию по оператору можно почитать [здесь](https://teletype.in/@pythontalk/walrus_operator).

## Проблема точности округления в Python

Проблема точности округления в Python, как и во многих других языках программирования, связана с представлением вещественных чисел в компьютерной арифметике.

Вещественные числа в Python представлены в формате двоичной десятичной дроби, что может привести к неточностям при округлении. Это происходит потому, что некоторые десятичные дроби не могут быть точно представлены как двоичные дроби.
"""

print(0.15 + 0.15 == 0.3)

print((0.1 + 0.15 + 0.05) == (0.1 + 0.1 + 0.1))

print(0.1 + 0.15 + 0.05)

print(0.1 + 0.1 + 0.1)

"""Стои избегать прямого сравнения float, если вам важна точность операций.

Чтобы обойти эту проблему, можно использовать функцию round(), чтобы округлить результат до нужного количества знаков после запятой:




"""

x = 0.1 + 0.1 + 0.1
y = 0.1 + 0.15 + 0.05

print(round(x, 2) == round(y, 2))

"""Более подробно можете почитать про это [здесь](https://teletype.in/@pythontalk/floating_point_problem).

## Тернарный условный оператор

Тернарный оператор в условиях Python - это способ написания коротких условных выражений.

Общий синтаксис тернарного оператора выглядит так:

`value_if_true if condition else value_if_false`
"""

# это стандартная запись

num = 7

if num % 2 == 0:
    print('Чётное')
else:
    print('Нечётное')

# а можно так
print('Чётное') if num % 2 == 0 else print('Нечётное')

"""Тернарный оператор в Python очень удобен для написания коротких и простых условных выражений, но его следует использовать с осторожностью в более сложных ситуациях, чтобы не ухудшить читаемость кода.

Определим квадрант, в котором находятся координаты
"""

x = float(input('Введите координату Х: '))
y = float(input('Введите координату Y: '))

if x != 0 and y != 0:
    if x > 0 and y > 0:
        print('I')
    elif x > 0 and y < 0:
        print('IV')
    elif y > 0:
        print('II')
    else:
        print('III')
else:
    print('На осях')

x = float(input('Введите координату Х: '))
y = float(input('Введите координату Y: '))

if x != 0 and y != 0:
    if x > 0:
        if y > 0:
            print('I')
        else:
            print('IV')
    else:
        if y > 0:
            print('II')
        else:
            print('III')
else:
    print('На осях')

x = float(input('Введите координату Х: '))
y = float(input('Введите координату Y: '))

if x != 0 and y != 0:
    if x > 0:
        print('I') if y > 0 else print('IV')
    else:
        print('II') if y > 0 else print('III')
else:
    print('На осях')

"""## match case

Начиная с версии 3.10 в Python появилась такая функциональность как pattern matching (сопоставление шаблонов). С помощью выражения match-case можно избавиться от довольно громоздких цепочек if-elif-else, например:
"""

language = "russian"

if language == "russian":
    print("Привет")
elif language == "english":
    print("Hello")
elif language == "german":
    print("Hallo")

"""Проверка `language == "something"` повторяется многократно. И совершенно ясно, что при каждой проверке мы обращаемся к переменной `language`. Если бы можно было не повторять `language == "something"`, код стал бы чище и короче.

Для этого можно использовать выражение match-case. Общая структура у него такая:

```
match element:
    case pattern1:
        # statements
    case pattern2:
        # statements
    case pattern3:
        # statements
```

В этой конструкции кода:

* `match element` означает «сопоставьте элемент со следующими шаблонами»
* затем каждое выражение `case pattern` сравнивает элемент с указанным шаблоном (это может быть, например, строка или число)
* если шаблон соответствует элементу, выполняется соответствующий блок кода, после этого оператор match-case заканчивает свою работу.

Обратите внимание, что блоки `case` имеют отступы от начала конструкции `match`. А инструкции каждого блока `case` имеют отступы от начала данного блока `case`.

Причем если выражение из `match` не соответствует ни одному из шаблонов `case`, то соответственно ни один из этих блоков `case` не выполняется.

Наш пример можно записать так:
"""

language = "russian"

match language:
    case "russian":
        print("Привет")
    case "english":
        print("Hello")
    case "german":
        print("Hallo")

"""Во многих случаях такой вариант делает код более читаемым, избавляет его от повторений.

Если необходимо, чтобы при несовпадении значений (если ни один из шаблонов `case` не соответствует выражению `match`) выполнялись некоторые действия по умолчанию, то в этом случае применяется шаблон `_` (прочерк):
"""

language = "russian"
match language:
    case "russian":
        print("Привет")
    case "english":
        print("Hello")
    case "german":
        print("Hallo")
    case _:
        print("Неизвестный язык")

"""Также можно определить блок case, который позволяет сравнивать сразу с несколькими знечениями. В этом случае значения разделяются вертикальной чертой (ИЛИ):


"""

language = "english"
match language:
    case "russian":
        print("Привет")
    case "british english" | "american english" | "english":
        print("Hello")
    case "german":
        print("Hallo")
    case _:
        print("Неизвестный язык")

"""## Регулярные выражения
Регулярные выражения (Regular Expressions, regex) — это формальный язык, основанный на использовании метасимволов, который применяется для работы с подстроками в тексте.

Регулярные выражения позвооляют создавать сложные правила поиска, валидации, замены в текстовых данных.

Одна из особенностей регулярных выражений в их универсальности, стоит вам выучить синтаксис, и вы сможете применять их в любом (почти) языке программирования (JavaScript, Java, VB, C #, C / C++, Python, Perl, Ruby, Delphi, R, Tcl, и многих других). Небольшие отличия касаются только наиболее продвинутых функций и версий синтаксиса, поддерживаемых движком.

>Если у вас есть проблема, и вы собираетесь ее решать с помощью регулярных выражений, тогда у вас будет уже две проблемы.

<cite>Шутка из интернетов (не шутка)</cite>. [Вот так](https://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html) может выглядеть страшная регулярка.

### Основы синтаксиса регулярных выражений

Для освоения даже базовых приёмов работы с регулярными выражениями придётся потратить некоторое время для заучивания метасимволов и отработки навыков по созданию шаблонов. Однако в будущем вы сможете сэкономить гораздо больше времени при написании кода, в котором будут обрабатываться строковые данные.

В таблице ниже представлены наиболее важные символы, использующиеся при создании регулярных выражений и примеры их применения.

<table>
<tbody>
<tr>
<td width="10%"><b>Символ</b></td>
<td width="50%"><b>Пояснение</b></td>
<td width="20%"><b>Пример выражения</b></td>
<td width="20%"><b>Пример строки</b></td>
</tr>
<tr>
<td>.</td>
<td>Любой символ</td>
<td>...</td>
<td>A!#</td>
</tr>
<tr>
<td>*</td>
<td>Ноль и более&nbsp;совпадений с выражением, заданным в качестве образца&nbsp;</td>
<td>123*</td>
<td>123123123</td>
</tr>
<tr>
<td>+</td>
<td>Одно и более&nbsp;совпадений с выражением, заданным в качестве образца&nbsp;</td>
<td>Ура!+</td>
<td>Ура!Ура!</td>
</tr>
<tr>
<td>?</td>
<td>Ноль или одно&nbsp;совпадение с выражением, заданным в качестве образца&nbsp;</td>
<td>один?</td>
<td>один</td>
</tr>
<tr>
<td>[ ]</td>
<td>Совпадение с любым из символов, заключённым в скобки</td>
<td>[a-z]</td>
<td>b</td>
</tr>
<tr>
<td>[^ ]</td>
<td>Совпадение с любым из символов, отсутствующим в скобках</td>
<td>[^a-z]</td>
<td>5</td>
</tr>
<tr>
<td>\</td>
<td>Экранирует специальные символы (т.е. позволяет использовать символы типа '.', '*', '?' в роли обычных элементов строки)</td>
<td>\*</td>
<td>*</td>
</tr>
</tbody>
</table>

В приведённой выше таблице отмечены две роли метасимвола `\`. С одной стороны, данный символ позволяет экранировать метасимволы, благодаря чему мы можем использовать точку, вопросительный знак, квадратные скобки и другие метасимволы по их прямому назначению (т.е. как обычную точку или вопросительный знак). Второе назначение обратного слэша — это сигнал о начале специальной последовательности, с помощью которой можно заменить определённую группу символов. Примеры таких последовательностей представлены в таблице ниже:

<table>
<tbody>
<tr>
<td width="20%"><b>Последовательность</b></td>
<td width="60%"><b>Описание</b></td>
<td width="20%"><b>Аналог с []</b></td>
</tr>
<tr>
<td>\d</td>
<td>Любая цифра</td>
<td>[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>Всё что угодно, кроме цифры</td>
<td>[^0-9]</td>
</tr>
<tr>
<td>\s</td>
<td>Любой пробельный символ</td>
<td>[ \t\n\r\f\v]</td>
</tr>
<tr>
<td>\S</td>
<td>Любой непробельный символ</td>
<td>[^ \t\n\r\f\v]</td>
</tr>
<tr>
<td>\w</td>
<td>Любая буква, цифра, знак подчёркивания</td>
<td>[a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>Всё что угодно, кроме букв, цифр и знака подчёркивания</td>
<td>[^a-zA-Z0-9_]</td>
</tr>
</tbody>
</table>

Квантификатор после символа или группы определяет, сколько раз предшествующее выражение может встречаться.

    {n,m}  повторений может быть от n до m включительно.
    {n,}   n и более повторений.
    {,m}   не более m повторений.
    {n}    ровно n повторений

Методы и функции, предназначенные для работы с регулярными выражениями, не входят в базовый функционал языка Python. Тем не менее эта проблема легко разрешима. При разработке программ на Python мы можем, помимо использования стандартной библиотеки, подключать дополнительные библиотеки и модули, тем самым расширяя свои возможности по созданию программ. Для Python написано огромное количество модулей и библиотек.

### Модуль `re`

Для работы с регулярными выражениями необходимо подключить дополнительный [модуль](https://teletype.in/@pythontalk/modules_packages_libs), который называется `re`. Подключение происходит с помощью команды `import`, после которой необходимо указать имя модуля:
"""

import re

"""Для вызова функции, которая является частью загруженного модуля, необходимо сначала указать имя модуля, и далее, через точку, указать имя функции.

#### Функция `search`

`search(pattern, string)` (англ. «поиск») ищет шаблон `pattern` в строке `string`. Хотя `search()` ищет шаблон во всей строке, возвращает он только первую найденную подстроку:
"""

text = '''Разработка языка Python была начата в конце 1980-х годов сотрудником голландского института CWI Гвидо ван Россумом.
Для распределённой ОС Amoeba требовался расширяемый скриптовый язык, и Гвидо начал писать Python на досуге,
позаимствовав некоторые наработки для языка ABC (Гвидо участвовал в разработке этого языка, ориентированного на обучение программированию).
В феврале 1991 года Гвидо опубликовал исходный текст в группе новостей alt.sources. Название языка произошло вовсе не от вида пресмыкающихся.
Автор назвал язык в честь популярного британского комедийного телешоу 1970-х "Летающий цирк Монти Пайтона".'''

"""Функция `search()` возвращает объект типа `match` (англ. «соответствовать»). Параметр `span` (англ. «диапазон») указывает диапазон индексов, подходящих под шаблон."""

res = re.search('\w+', text)

print(res)

"""Шаблону `\w+` соответствует любая подстрока, содержащая одну и более букв, цифр или символ подчёркивания. Так как под шаблон не подходит пробел, метод вернул всё, что идёт до первого пробела.

Если нам не нужны дополнительные сведения о диапазоне, выведем только найденную подстроку методом `group()`:
"""

print(res.group())

"""Можем начало и конец диапазона извлечь как integer:"""

print(res.start())
print(res.end())

"""Достанем данные, содержащие русские буквы или пробел между символами `"`"""

res = re.search('"[А-Яа-яЁё ]+"', text).group()
print(res)

"""Обратите внимание, что мы учли все символы, содержащиеся в нужной подстроке, в том числе — пробел.

#### Функция `sub`

`sub(pattern, repl, string)` (от англ. substring, «подстрока») ищет подстроку `pattern` в строке `string` и заменяет его на подстроку `repl` (от англ. replace — «заменить»).

Произведем замену "Регулярные выражения" во всех формах на "regex"
"""

text = """Что такое регулярные выражения и как их использовать?
Говоря простым языком, регулярное выражение — это последовательность символов, используемая для поиска и замены текста в строке или файле. Как уже было упомянуто,
их поддерживает множество языков общего назначения: Python, Perl, R.
Так что изучение регулярных выражений рано или поздно пригодится."""

new_text = re.sub('[Рр]егулярн[а-я]{2,3} выражен[а-я]{2,4}', 'regex', text)

print(new_text)

"""Простой способ удалить все служебные символы"""

text = """Что такое регулярные выражения и как их использовать?
Говоря простым языком, регулярное выражение — это последовательность символов, используемая для поиска и замены текста в строке или файле. Как уже было упомянуто,
их поддерживает множество языков общего назначения: Python, Perl, R.
Так что изучение регулярных выражений рано или поздно пригодится."""

new_text = re.sub('[^\w\s]', '', text)
print(new_text)

"""## Рекомендуемые материалы

1. Подбора бесплатных тренажёров по Python: [часть 1](https://teletype.in/@pythontalk/python_exercises_1), [часть 2](https://teletype.in/@pythontalk/python_exercises_2).
2. Литература:
 - А Byte of Python [англ. версия](https://python.swaroopch.com/), [рус. перевод](https://zhekazuev.github.io/byte-of-python-ru/). Легально, бесплатно, без СМС и регистрации.
 - [Адитья Бхаргава, Грокаем алгоритмы](https://bit.ly/3IWxklj). Бесплатно сами.
3. [Тренажёры по регуляркам](https://regexcrossword.com/howtoplay)
4. Сервисы для работы с регулярными выражениями:
    - [regex101](https://regex101.com/)
    - [ihateregex](https://ihateregex.io)



"""

